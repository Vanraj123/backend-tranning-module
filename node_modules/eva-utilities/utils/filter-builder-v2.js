function buildQueryFromFilters(filters, paramIndex = 1, options = {}) {
    const { caseSensitive = false, useOrConditions = false } = options;
    let whereClauses = [];
    let params = [];
    let placeholders = [];
    filters.forEach((filter) => {
        const operator = filter.operator.toLowerCase();
        const dbWords = ["group", "order", "user", "date"]; // example predefined DB words

        let field = filter.field;

        if (dbWords.includes(field)) {
            field = `"${field}"`;
        }

        let clause = "";

        // Determine if the field is a boolean field based on the value
        const isLikelyBooleanField =
            typeof filter.value === "boolean" ||
            filter.value === "true" ||
            filter.value === "false";
        // field.startsWith('is_');

        // Skip case conversion for array values or null/undefined values
        const isArrayValue = Array.isArray(filter.value);

     const isNumericSearch =
        !isArrayValue &&
        !isLikelyBooleanField &&
        filter.value !== null &&
        filter.value !== undefined &&
        !isNaN(Number(filter.value));

        // Handle case sensitivity for text fields, but skip for boolean fields and arrays
        const fieldExpr =
            isLikelyBooleanField || isArrayValue || caseSensitive
                ? field
                : `LOWER(${field})`;

        // Process the value based on its type and the field type
        let value;
        if (isArrayValue) {
            // Don't try to process array values here
            value = filter.value;
        } else if (filter.value === null || filter.value === undefined) {
            // Handle null/undefined values
            value = null;
        } else if (isLikelyBooleanField) {
            // For boolean fields, convert to proper boolean value
            if (typeof filter.value === "string") {
                value = filter.value.toLowerCase() === "true";
            } else {
                value = Boolean(filter.value);
            }
        } else if (
            typeof filter.value === "number" ||
            typeof filter.value === "boolean"
        ) {
            // For text fields with non-string values
            value = caseSensitive
                ? String(filter.value)
                : String(filter.value).toLowerCase();
        } else if (typeof filter.value === "string") {
            // For normal text fields
            value = caseSensitive ? filter.value : filter.value.toLowerCase();
        } else {
            // Default case for other types
            value = filter.value;
        }

        switch (operator) {
                // Text operators
             case 'contains':
                // âœ… If it looks like a number, cast the DB column to text for ILIKE.
                // Otherwise, keep the normal case-insensitive/text logic.
                if (isNumericSearch) {
                  clause = `CAST(${field} AS TEXT) ILIKE $${paramIndex}`;
                } else {
                  clause = `${fieldExpr} ILIKE $${paramIndex}`;
                }
                params.push(`%${value}%`);
                break;
        
              case 'does not contain':
                if (isNumericSearch) {
                  clause = `CAST(${field} AS TEXT) NOT ILIKE $${paramIndex}`;
                } else {
                  clause = `${fieldExpr} NOT ILIKE $${paramIndex}`;
                }
                params.push(`%${value}%`);
                break;
            case "equals":
                if (isLikelyBooleanField) {
                    clause = `${field} = $${paramIndex}`;
                    params.push(value);
                } else {
                    clause = `TRIM(${fieldExpr}) = $${paramIndex}`;
                    params.push(value.trim());
                }
                break;
            case "does not equal":
                if (isLikelyBooleanField) {
                    clause = `${field} != $${paramIndex}`;
                    params.push(value);
                } else {
                    clause = `COALESCE(TRIM(${fieldExpr}), '___NULL___') != $${paramIndex}`;
                    params.push(value.trim());
                }
                break;
            case "begins with":
                clause = `${fieldExpr} LIKE $${paramIndex}`;
                params.push(`${value}%`);
                break;
            case "ends with":
                clause = `${fieldExpr} LIKE $${paramIndex}`;
                params.push(`%${value}`);
                break;
            case "blank":
                clause = `(${field} IS NULL OR ${field} = '')`;
                break;
            case "not blank":
                clause = `(${field} IS NOT NULL AND ${field} != '')`;
                break;
            case "number blank":
                clause = `(${field} IS NULL)`;
                break;
            case "number not blank":
                clause = `(${field} IS NOT NULL)`;
                break;
            case "is in":
                if (!Array.isArray(value) || value.length === 0) {
                    throw new Error(`Value must be a non-empty array`);
                }

                placeholders = value.map((_, i) => `$${paramIndex + i}`);
                clause = `${fieldExpr} IN (${placeholders.join(", ")})`;
                params.push(...value);
                paramIndex += value.length - 1;
                break;

            case "is not in":
                if (!Array.isArray(value) || value.length === 0) {
                    throw new Error(`Value must be a non-empty array`);
                }

                placeholders = value.map((_, i) => `$${paramIndex + i}`);
                clause = `${fieldExpr} NOT IN (${placeholders.join(", ")})`;
                params.push(...value);
                paramIndex += value.length - 1;
                break;

            // Number operators
            case "greater than":
                clause = `${field} > $${paramIndex}`;
                params.push((filter.value));
                break;
            case "less than":
                clause = `${field} < $${paramIndex}`;
                params.push((filter.value));
                break;
            case "greater than or equal":
                clause = `${field} >= $${paramIndex}`;
                params.push((filter.value));
                break;
            case "less than or equal":
                clause = `${field} <= $${paramIndex}`;
                params.push((filter.value));
                break;
            case "number equals":
                clause = `${field} = $${paramIndex}`;
                params.push((filter.value));
                break;
            case "number not equals":
                clause = `${field} != $${paramIndex}`;
                params.push((filter.value));
                break;
            case "number between":
                if (!Array.isArray(filter.value) || filter.value.length !== 2) {
                    throw new Error("Number between requires an array of two numbers");
                }
                clause = `${field} BETWEEN $${paramIndex} AND $${paramIndex + 1}`;
                params.push((filter.value[0]), (filter.value[1]));
                paramIndex++; // Extra increment for second parameter
                break;

            // Date operators
            case "date equals":
                clause = `DATE(${field}) = $${paramIndex}`;
                params.push(filter.value);
                break;
            case "date before":
                clause = `DATE(${field}) < $${paramIndex}`;
                params.push(filter.value);
                break;
            case "date after":
                clause = `DATE(${field}) > $${paramIndex}`;
                params.push(filter.value);
                break;
            case "date on or before":
                clause = `DATE(${field}) <= $${paramIndex}`;
                params.push(filter.value);
                break;
            case "date on or after":
                clause = `DATE(${field}) >= $${paramIndex}`;
                params.push(filter.value);
                break;
            case "date between":
                if (!Array.isArray(filter.value) || filter.value.length !== 2) {
                    throw new Error("Date between requires an array of two dates");
                }
                clause = `DATE(${field}) BETWEEN $${paramIndex} AND $${paramIndex + 1}`;
                params.push(filter.value[0], filter.value[1]);
                paramIndex++; // Extra increment for second parameter
                break;
            case "date is blank":
                clause = `${field} IS NULL`;
                break;
            case "date is not blank":
                clause = `${field} IS NOT NULL`;
                break;

            default:
                throw new Error(`Unsupported operator: ${filter.operator}`);
        }

        whereClauses.push(clause);

        // Only increment param index if we used a parameter
        if (
            !["blank", "not blank", "date is blank", "date is not blank", "number blank", "number not blank"].includes(
                operator,
            )
        ) {
            paramIndex++;
        }
    });

    const whereClause =
        whereClauses.length > 0
            ? ` ${whereClauses.join(useOrConditions ? " OR " : " AND ")}`
            : "";

    return {
        query: `${whereClause}`,
        params: params,
    };
}

function buildMultiSort(sortArray) {
    if (!Array.isArray(sortArray) || sortArray.length === 0) return "";

    return sortArray.reduce((query, sort, index) => {
        if (!sort.colId) return query;
        const direction = sort.sort?.toLowerCase() === "asc" ? "ASC" : "DESC";
        return (
            query + (index === 0 ? " ORDER BY " : ", ") + `${sort.colId} ${direction}`
        );
    }, "");
}

const Joi = require("joi");

const filterSchema = Joi.object({
    field: Joi.string().required().label("Field name"),
    operator: Joi.string()
        .valid(
            // Text operators
            "contains",
            "does not contain",
            "equals",
            "does not equal",
            "begins with",
            "ends with",
            "blank",
            "not blank",
            "number blank",
            "number not blank",

            // Number operators
            "greater than",
            "less than",
            "greater than or equal",
            "less than or equal",
            "number equals",
            "number not equals",
            "number between",

            // Date operators
            "date equals",
            "date before",
            "date after",
            "date on or before",
            "date on or after",
            "date between",
            "date is blank",
            "date is not blank",

            "is in",
            "is not in",
        )
        .required()
        .label("Operator"),

    value: Joi.when("operator", {
        switch: [
            // Operators that require a string value (now accepting number and boolean too)
            {
                is: Joi.valid(
                    "contains",
                    "does not contain",
                    "equals",
                    "does not equal",
                    "begins with",
                    "ends with",
                    "date equals",
                    "date before",
                    "date after",
                    "date on or before",
                    "date on or after",

                ),
                then: Joi.alternatives()
                    .try(Joi.string(), Joi.number(), Joi.boolean())
                    .required(),
            },

            {
                is: Joi.valid("is in", "is not in"),
                then: Joi.alternatives()
                    .try(
                        Joi.array().items(Joi.string()).min(1),
                        Joi.array().items(Joi.number()).min(1),
                        Joi.array().items(Joi.boolean()).min(1)
                    )
                    .required()
            },

            // Operators that require a number value (now also accepting strings that can be converted to numbers)
            {
                is: Joi.valid(
                    "greater than",
                    "less than",
                    "greater than or equal",
                    "less than or equal",
                    "number equals",
                    "number not equals",
                ),
                then: Joi.alternatives()
                    .try(
                        Joi.number().unsafe(),
                        Joi.string().custom((value, helpers) => {
                            const num = Number(value);
                            if (isNaN(num)) {
                                return helpers.error("any.invalid");
                            }
                            return num;
                        }),
                    )
                    .required(),
            },

            // Operators that require an array of two numbers/dates
            {
                is: Joi.valid("number between", "date between"),
                then: Joi.array()
                    .items(
                        Joi.when(Joi.ref("...operator"), {
                            is: "number between",
                            then: Joi.alternatives()
                                .try(
                                    Joi.number(),
                                    Joi.string().custom((value, helpers) => {
                                        const num = Number(value);
                                        if (isNaN(num)) {
                                            return helpers.error("any.invalid");
                                        }
                                        return num;
                                    }),
                                )
                                .required(),
                            otherwise: Joi.string().isoDate().required(),
                        }),
                    )
                    .length(2)
                    .required(),
            },

            // Operators that don't need a value
            {
                is: Joi.valid(
                    "blank",
                    "not blank",
                    "date is blank",
                    "date is not blank",
                    "number blank",
                    "number not blank",
                ),
                then: Joi.forbidden(),
            },
        ],
    }),

    caseSensitive: Joi.boolean().default(false),
    nullsFirst: Joi.boolean().default(false),
});

const filtersSchema = Joi.array().items(filterSchema).max(20); // Limit to 20 filters

const sortSchema = Joi.object({
    colId: Joi.string().required().label("Column ID"),
    sort: Joi.string()
        .valid("asc", "desc", "ASC", "DESC")
        .default("asc")
        .label("Sort direction"),
    nullsFirst: Joi.boolean().default(false),
});

const sortArraySchema = Joi.array().items(sortSchema).max(5); // Limit to 5 sort columns

function validateFiltersAndSorts(filters, sortArray) {
    // Default to empty array if undefined/null
    const filtersToValidate =
        filters === undefined || filters === null ? [] : filters;
    const sortArrayToValidate =
        sortArray === undefined || sortArray === null ? [] : sortArray;

    // Validate filters
    const { error: filterError, value: validatedFilters } =
        filtersSchema.validate(filtersToValidate, {
            abortEarly: false,
        });

    // Validate sort array
    const { error: sortError, value: validatedSorts } = sortArraySchema.validate(
        sortArrayToValidate,
        {
            abortEarly: false,
        },
    );

    // Combine errors if both exist
    const errors = [];
    if (filterError) errors.push(...filterError.details);
    if (sortError) errors.push(...sortError.details);

    if (errors.length > 0) {
        const errorMessages = errors.map((err) => err.message);
        throw new Error(`Validation failed: ${errorMessages.join("; ")}`);
    }

    return {
        filters: validatedFilters,
        sort: validatedSorts,
    };
}

module.exports = {
    buildQueryFromFilters,
    buildMultiSort,
    validateFiltersAndSorts,
};
