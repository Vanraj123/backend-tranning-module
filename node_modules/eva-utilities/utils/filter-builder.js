const validations = {
    text: {
        contains: (field, value, params) => `${field} ILIKE $${params.push(`%${value}%`)}`,
        notContains: (field, value, params) => `${field} NOT ILIKE $${params.push(`%${value}%`)}`,
        startsWith: (field, value, params) => `${field} ILIKE $${params.push(`${value}%`)}`,
        endsWith: (field, value, params) => `${field} ILIKE $${params.push(`%${value}`)}`,
        equals: (field, value, params) => `${field} = $${params.push(value)}`,
        notEqual: (field, value, params) => `${field} != $${params.push(value)}`,
        blank: (field) => `${field} IS NULL`,
        notBlank: (field) => `${field} IS NOT NULL`,
    },
    number: {
        equals: (field, value, params) => `${field} = $${params.push(value)}`,
        notEqual: (field, value, params) => `${field} != $${params.push(value)}`,
        greaterThan: (field, value, params) => `${field} > $${params.push(value)}`,
        greaterThanOrEqual: (field, value, params) => `${field} >= $${params.push(value)}`,
        lessThan: (field, value, params) => `${field} < $${params.push(value)}`,
        lessThanOrEqual: (field, value, params) => `${field} <= $${params.push(value)}`,
        between: (field, filter, filterTo, params) => `${field} BETWEEN $${params.push(filter)} AND $${params.push(filterTo)}`,
        blank: (field) => `${field} IS NULL`,
        notBlank: (field) => `${field} IS NOT NULL`,
    },
    date: {
        equals: (field, value, params) => `${field}::date = $${params.push(value)}::date`,
        notEqual: (field, value, params) => `${field}::date != $${params.push(value)}::date`,
        after: (field, value, params) => `${field}::date > $${params.push(value)}::date`,
        lessThank: (field, value, params) => `${field}::date < $${params.push(value)}::date`,
        inRange: (field, filter, filterTo, params) => `${field}::date BETWEEN $${params.push(filter)}::date AND $${params.push(filterTo)}::date`,
        blank: (field) => `${field}::date IS NULL`,
        notBlank: (field) => `${field}::date IS NOT NULL`,
    }
}

const buildFilters = (filters, params = [], index = 1) => {
    const queryParts = [];
    for (const [field, filter] of Object.entries(filters)) {
        if (!filter.type) {
            let subQueryParts = [];
            for (const condition of filter.conditions) {
                let query;
                if (filter.type === 'between' || filter.type == 'inRange') {
                    filter.filterType['number'] ?
                        query = validations[condition.filterType][condition.type](field, condition.filter, condition.filterTo, params) :
                        query = validations[condition.filterType][condition.type](field, condition.dateFrom, condition.dateTo, params);
                }
                else {
                    query = validations[condition.filterType][condition.type](field, condition.filter, params);
                }
                subQueryParts.push(`${query}`);
            }
            queryParts.push(`(${subQueryParts.join(` ${filter.operator} `)})`);
        }
        else {
            let query;
            if (filter.type === 'between' || filter.type == 'inRange') {
                filter.filterType['number'] ?
                    query = validations[filter.filterType][filter.type](field, filter.filter, filter.filterTo, params) :
                    query = validations[filter.filterType][filter.type](field, filter.dateFrom, filter.dateTo, params);
            }
            else {
                query = validations[filter.filterType][filter.type](field, filter.filter, params);
            }
            queryParts.push(`(${query})`);
        }
    }
    return queryParts.join(" AND ");
};

const generateFilterQuery = (filters) => {
    if (!filters || typeof filters !== "object") {
        return {
            query: "",
            params: [],
        };
    }

    const params = [];
    const whereClause = buildFilters(filters, params);

    return {
        query: whereClause ? `WHERE ${whereClause}` : "",
        params,
    };
};

module.exports = {
    generateFilterQuery,
};
